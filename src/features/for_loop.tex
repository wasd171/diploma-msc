\section{Support of the \texttt{FOR} loop}
\label{sec:for_loop}

\textit{Components affected}: \textbf{Sequencer} (\ref{sec:sequencer}).

\textit{Motivation}: While the sequencer is able to execute the pseudo-\texttt{FOR} loop as shown on the Listing \ref{listing:goto_as_for} we would still prefer to have it implemented as a standalone construction for the sake of simplicity and reducing the mental overhead of the users. Additionally the usage of \texttt{GOTO} command is generally considered \cite{Dijkstra1968} harmful, leading to the unstructured spaghetti code \cite{Cram2005}.

\begin{lstlisting}[
	caption={Implementing \texttt{FOR} with \texttt{GOTO}}, 
	label={listing:goto_as_for}, 
	language=n2EDMScript
]
SET i = 0
LABEL "FOR_START_17"
IF $i < 5 THEN
...
SET i = $i + 1
GOTO "FOR_START_17"
ELSE
ENDIF
\end{lstlisting}

\textit{Requirements}: We introduce 3 new commands that the sequencer should be able to handle:

\begin{itemize}
	\item \texttt{FOR (init; test; iterate)} or \texttt{FOR ((init; test; iterate))}. Amount of whitespace characters is arbitrary, round brackets are allowed as a part of every argument, but amount of "\texttt{(}" and "\texttt{)}" per argument needs to be balanced. Nested \texttt{FOR} blocks are allowed.
	\begin{itemize}
		\item \texttt{init}: an expression that is being executed once to init the state of the loop variable. It follows the semantic of the \texttt{SET} operator, for example \texttt{i = 0} is valid.
		\item \texttt{test}: an expression that produces a boolean value when evaluated. We run this check on every iteration, including the first one. Semantically similar to the argument of the \texttt{IF} block, so \texttt{\$i < 5} is allowed. If the output is \texttt{False}, skipping the lines until a \texttt{DONE} block is encountered. Otherwise continues execution as usual.
		\item \texttt{iterate}: an expression that is used to modify the loop variable. Gets evaluated at the end of every cycle. It borrows the structure of the \texttt{SET} command, usually using the loop variable itself in a following manner: \texttt{i = \$i + 1}
	\end{itemize}
	\item \texttt{DO}: contrary to the name it does nothing. If encountered, must have a valid \texttt{FOR} statement in a previous line of the sequence.
	\item \texttt{DONE}: marks the end of the \texttt{FOR} loop. Redirects to the beginning of the loop for the next iteration.
\end{itemize}

We should be able to replace the Listing \ref{listing:goto_as_for} with the code of the Listing \ref{listing:for_loop_example}.
\begin{lstlisting}[
	caption={Example of the \texttt{FOR} loop}, 
	label={listing:for_loop_example},
	language=n2EDMScript
]
FOR (i = 0; $i < 5; i = $i + 1)
DO
...
DONE
\end{lstlisting}

\textit{Implementation details}: 

\begin{itemize}
	\item Contrary to the implementation of the \texttt{IF/ELSE/ENDIF} blocks the \texttt{FOR} loop does not need to be complete all the times, rather if the \texttt{FOR.test} yielded \texttt{False} we would set a \texttt{skipUntilDone} flag and continue the execution until the matching \texttt{DONE} is found
	\item Current scope of the variables is always global, so one might prefer to use different iteration variables for nested loops to prevent confusing results
	\item Sequencer supports powerful inline editing/removal of the lines. We do not attempt to prevent cases like \texttt{GOTO} from the loop body or \texttt{REMOVELINE} of \texttt{FOR} while iterating. However the sequencer will always try to find the root of the problem and notify the user about it
	\item Default strategy for the non-parseable lines is to skip them
\end{itemize}

%\begin{lstlisting}[
%	language=JavaScript, 
%	caption={Simplified overview of the \texttt{FOR} loop implementation},
%	label={listing:for_loop_implementation}
%]
%let skipUntilDone = false
%let forDelta = 0
%
%while (canReadNextSequenceLine) {
%	++currentLineNumber
%
%	if (skipUntilDone) {
%		if (isCurrentLine('FOR')) {
%			++forDelta
%		} else if (isCurrentLine('DONE')) {
%			--forDelta
%
%			if (forDelta == 0) {
%				skipUntilDone = false
%			}
%		}
%	} else if (isCurrentLine('FOR')) {
%		setVariable(forLine.init)
%		skipUntilDone = !evaluateExpression(forLine.test)
%
%		if (skipUntilDone) {
%			forDelta = 1
%		}
%	} else if (isCurrentLine('DO')) {
%		const savedCurrentLineNumber = currentLineNumber
%		let doneDelta = 1
%
%		do {
%			--currentLineNumber
%			if (isCurrentLine('FOR')) {
%				--doneDelta
%			} else if (isCurrentLine('DONE')) {
%				++doneDelta
%			}
%		} while (!(doneDelta == 0 || currentLineNumber == 0))
%
%		if (doneDelta != 0) {
%			currentLineNumber = savedCurrentLineNumber
%		} else {
%			setVariable(forLine.iterate)
%			const canRunAgain = evaluateExpression(forLine.test)
%
%			if (!canRunAgain) {
%				currentLineNumber = savedCurrentLineNumber
%			}
%		}
%	}
%}
%\end{lstlisting}